package protocol

import (
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"os"

	"github.com/bblfsh/sdk"

	"github.com/jessevdk/go-flags"
)

// DriverMain is the implementation of a driver main function. It is meant to be
// called from an autogenerated main.go in each driver.
func DriverMain(version, build string) {
	if len(os.Args) == 1 {
		cmd := &serveCommand{}
		if err := cmd.Execute(nil); err != nil {
			os.Exit(-1)
		}

		return
	}

	parser := flags.NewNamedParser(os.Args[0], flags.Default)
	parser.AddCommand("serve", "", "", &serveCommand{})
	parser.AddCommand("parse-native", "", "", &parseNativeASTCommand{})

	if _, err := parser.Parse(); err != nil {
		if _, ok := err.(*flags.Error); ok {
			parser.WriteHelp(os.Stdout)
			fmt.Printf("\nBuild information\n  commit: %s\n  date:%s\n", version, build)
		}

		os.Exit(1)
	}

}

type serveCommand struct{}

func (c *serveCommand) Execute(args []string) error {
	client, err := ExecNative(sdk.NativeBin)
	if err != nil {
		return fmt.Errorf("error executing native: %s", err.Error())
	}

	err = serve(os.Stdin, os.Stdout, client.Request)
	if err != nil {
		return fmt.Errorf("error serving: %s", err.Error())
	}

	if cerr := client.Close(); cerr != nil {
		if err == nil {
			err = cerr
		}

		if client.cmd.Process != nil {
			client.cmd.Process.Kill()
		}

		if err != nil {
			return fmt.Errorf("error closing native: %s", err.Error())
		}
	}

	return nil
}

type parseNativeASTCommand struct {
	Args struct {
		File string
	} `positional-args:"yes"`
}

func (c *parseNativeASTCommand) Execute(args []string) error {
	f := c.Args.File

	client, err := ExecNative(sdk.NativeBin)
	if err != nil {
		return err
	}

	b, err := ioutil.ReadFile(f)
	if err != nil {
		return fmt.Errorf("error reading file %s: %s", f, err.Error())
	}

	req := &Request{
		Action:  ParseAST,
		Content: string(b),
	}

	resp, err := client.Request(req)
	if err != nil {
		return fmt.Errorf("request failed: %q", err)
	}

	e := json.NewEncoder(os.Stdout)
	if err := e.Encode(resp); err != nil {
		return err
	}

	return nil
}

func newFatalResponse(err error) *Response {
	return &Response{
		Status: Fatal,
		Errors: []string{err.Error()},
	}
}

func serve(in io.Reader, out io.Writer, f func(req *Request) (*Response, error)) error {
	dec := json.NewDecoder(in)
	enc := json.NewEncoder(out)
	for {
		req := &Request{}
		if err := dec.Decode(req); err != nil {
			return err
		}

		resp, err := f(req)
		if err != nil {
			if err := enc.Encode(newFatalResponse(err)); err != nil {
				return err
			}

			continue
		}

		if err := enc.Encode(resp); err != nil {
			if err := enc.Encode(newFatalResponse(err)); err != nil {
				return err
			}
		}
	}

	return nil
}
