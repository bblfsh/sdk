// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: driver.proto

package protocol

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	_ "github.com/golang/protobuf/ptypes/timestamp"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type Mode int32

const (
	// DefaultMode selects the transformation mode that is considered to produce UAST of the best quality.
	Mode_DefaultMode Mode = 0
	// Native disables any UAST transformations and emits a native language AST as returned by the parser.
	Mode_Native Mode = 1
	// Preprocessed runs only basic transformation over native AST (normalize positional info, type fields).
	Mode_Preprocessed Mode = 2
	// Annotated UAST is based on native AST, but provides role annotations for nodes.
	Mode_Annotated Mode = 4
	// Semantic UAST normalizes native AST nodes to a unified structure where possible.
	Mode_Semantic Mode = 8
)

var Mode_name = map[int32]string{
	0: "DEFAULT_MODE",
	1: "NATIVE",
	2: "PREPROCESSED",
	4: "ANNOTATED",
	8: "SEMANTIC",
}

var Mode_value = map[string]int32{
	"DEFAULT_MODE": 0,
	"NATIVE":       1,
	"PREPROCESSED": 2,
	"ANNOTATED":    4,
	"SEMANTIC":     8,
}

func (x Mode) String() string {
	return proto.EnumName(Mode_name, int32(x))
}

func (Mode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_521003751d596b5e, []int{0}
}

type DevelopmentStatus int32

const (
	DevelopmentStatus_Inactive DevelopmentStatus = 0
	DevelopmentStatus_Planning DevelopmentStatus = 1
	DevelopmentStatus_PreAlpha DevelopmentStatus = 2
	DevelopmentStatus_Alpha    DevelopmentStatus = 3
	DevelopmentStatus_Beta     DevelopmentStatus = 4
	DevelopmentStatus_Stable   DevelopmentStatus = 5
	DevelopmentStatus_Mature   DevelopmentStatus = 6
)

var DevelopmentStatus_name = map[int32]string{
	0: "DEV_INACTIVE",
	1: "DEV_PLANNING",
	2: "DEV_PREALPHA",
	3: "DEV_ALPHA",
	4: "DEV_BETA",
	5: "DEV_STABLE",
	6: "DEV_MATURE",
}

var DevelopmentStatus_value = map[string]int32{
	"DEV_INACTIVE": 0,
	"DEV_PLANNING": 1,
	"DEV_PREALPHA": 2,
	"DEV_ALPHA":    3,
	"DEV_BETA":     4,
	"DEV_STABLE":   5,
	"DEV_MATURE":   6,
}

func (x DevelopmentStatus) String() string {
	return proto.EnumName(DevelopmentStatus_name, int32(x))
}

func (DevelopmentStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_521003751d596b5e, []int{1}
}

// ParseRequest is a request to parse a file and get its UAST.
type ParseRequest struct {
	// Content stores the content of a source file. Required.
	Content string `protobuf:"bytes,1,opt,name=content,proto3" json:"content,omitempty"`
	// Language can be set optionally to disable automatic language detection.
	Language string `protobuf:"bytes,2,opt,name=language,proto3" json:"language,omitempty"`
	// Filename can be set optionally to assist automatic language detection.
	Filename string `protobuf:"bytes,3,opt,name=filename,proto3" json:"filename,omitempty"`
	// Mode sets a transformation pipeline used for UAST.
	Mode                 Mode     `protobuf:"varint,4,opt,name=mode,proto3,enum=gopkg.in.bblfsh.sdk.v2.protocol.Mode" json:"mode,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ParseRequest) Reset()         { *m = ParseRequest{} }
func (m *ParseRequest) String() string { return proto.CompactTextString(m) }
func (*ParseRequest) ProtoMessage()    {}
func (*ParseRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_521003751d596b5e, []int{0}
}
func (m *ParseRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ParseRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ParseRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ParseRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ParseRequest.Merge(m, src)
}
func (m *ParseRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ParseRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ParseRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ParseRequest proto.InternalMessageInfo

// ParseResponse is the reply to ParseRequest.
type ParseResponse struct {
	// UAST is a binary encoding of the resulting UAST.
	Uast []byte `protobuf:"bytes,1,opt,name=uast,proto3" json:"uast,omitempty"`
	// Language that was automatically detected.
	Language string `protobuf:"bytes,2,opt,name=language,proto3" json:"language,omitempty"`
	// Errors is a list of parsing errors.
	// Only set if parser was able to return a response. Otherwise gRPC error codes are used.
	Errors               []*ParseError `protobuf:"bytes,3,rep,name=errors,proto3" json:"errors,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ParseResponse) Reset()         { *m = ParseResponse{} }
func (m *ParseResponse) String() string { return proto.CompactTextString(m) }
func (*ParseResponse) ProtoMessage()    {}
func (*ParseResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_521003751d596b5e, []int{1}
}
func (m *ParseResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ParseResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ParseResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ParseResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ParseResponse.Merge(m, src)
}
func (m *ParseResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ParseResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ParseResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ParseResponse proto.InternalMessageInfo

type ParseError struct {
	// Text is an error message.
	Text                 string   `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ParseError) Reset()         { *m = ParseError{} }
func (m *ParseError) String() string { return proto.CompactTextString(m) }
func (*ParseError) ProtoMessage()    {}
func (*ParseError) Descriptor() ([]byte, []int) {
	return fileDescriptor_521003751d596b5e, []int{2}
}
func (m *ParseError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ParseError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ParseError.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ParseError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ParseError.Merge(m, src)
}
func (m *ParseError) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ParseError) XXX_DiscardUnknown() {
	xxx_messageInfo_ParseError.DiscardUnknown(m)
}

var xxx_messageInfo_ParseError proto.InternalMessageInfo

type Version struct {
	Version              string    `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	Build                time.Time `protobuf:"bytes,2,opt,name=build,proto3,stdtime" json:"build"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Version) Reset()         { *m = Version{} }
func (m *Version) String() string { return proto.CompactTextString(m) }
func (*Version) ProtoMessage()    {}
func (*Version) Descriptor() ([]byte, []int) {
	return fileDescriptor_521003751d596b5e, []int{3}
}
func (m *Version) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Version) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Version.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Version) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Version.Merge(m, src)
}
func (m *Version) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Version) XXX_DiscardUnknown() {
	xxx_messageInfo_Version.DiscardUnknown(m)
}

var xxx_messageInfo_Version proto.InternalMessageInfo

type Manifest struct {
	// Name is a human-readable language or driver name.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Language is a Babelfish language identifier.
	Language string `protobuf:"bytes,2,opt,name=language,proto3" json:"language,omitempty"`
	// Aliases is a list of alternative language identifiers from Enry/Linguist.
	Aliases []string `protobuf:"bytes,3,rep,name=aliases,proto3" json:"aliases,omitempty"`
	// Version of the language driver.
	Version *Version `protobuf:"bytes,4,opt,name=version,proto3" json:"version,omitempty"`
	// Status of the driver development.
	Status DevelopmentStatus `protobuf:"varint,5,opt,name=status,proto3,enum=gopkg.in.bblfsh.sdk.v2.protocol.DevelopmentStatus" json:"status,omitempty"`
	// Features this driver supports.
	Features             []string `protobuf:"bytes,6,rep,name=features,proto3" json:"features,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Manifest) Reset()         { *m = Manifest{} }
func (m *Manifest) String() string { return proto.CompactTextString(m) }
func (*Manifest) ProtoMessage()    {}
func (*Manifest) Descriptor() ([]byte, []int) {
	return fileDescriptor_521003751d596b5e, []int{4}
}
func (m *Manifest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Manifest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Manifest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Manifest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Manifest.Merge(m, src)
}
func (m *Manifest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Manifest) XXX_DiscardUnknown() {
	xxx_messageInfo_Manifest.DiscardUnknown(m)
}

var xxx_messageInfo_Manifest proto.InternalMessageInfo

type VersionRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VersionRequest) Reset()         { *m = VersionRequest{} }
func (m *VersionRequest) String() string { return proto.CompactTextString(m) }
func (*VersionRequest) ProtoMessage()    {}
func (*VersionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_521003751d596b5e, []int{5}
}
func (m *VersionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VersionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VersionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VersionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VersionRequest.Merge(m, src)
}
func (m *VersionRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *VersionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VersionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VersionRequest proto.InternalMessageInfo

type VersionResponse struct {
	Version              *Version `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VersionResponse) Reset()         { *m = VersionResponse{} }
func (m *VersionResponse) String() string { return proto.CompactTextString(m) }
func (*VersionResponse) ProtoMessage()    {}
func (*VersionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_521003751d596b5e, []int{6}
}
func (m *VersionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VersionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VersionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VersionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VersionResponse.Merge(m, src)
}
func (m *VersionResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *VersionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_VersionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_VersionResponse proto.InternalMessageInfo

type SupportedLanguagesRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SupportedLanguagesRequest) Reset()         { *m = SupportedLanguagesRequest{} }
func (m *SupportedLanguagesRequest) String() string { return proto.CompactTextString(m) }
func (*SupportedLanguagesRequest) ProtoMessage()    {}
func (*SupportedLanguagesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_521003751d596b5e, []int{7}
}
func (m *SupportedLanguagesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SupportedLanguagesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SupportedLanguagesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SupportedLanguagesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SupportedLanguagesRequest.Merge(m, src)
}
func (m *SupportedLanguagesRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SupportedLanguagesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SupportedLanguagesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SupportedLanguagesRequest proto.InternalMessageInfo

type SupportedLanguagesResponse struct {
	// Languages is a list of driver manifests for each language supported by the server.
	Languages            []*Manifest `protobuf:"bytes,1,rep,name=languages,proto3" json:"languages,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *SupportedLanguagesResponse) Reset()         { *m = SupportedLanguagesResponse{} }
func (m *SupportedLanguagesResponse) String() string { return proto.CompactTextString(m) }
func (*SupportedLanguagesResponse) ProtoMessage()    {}
func (*SupportedLanguagesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_521003751d596b5e, []int{8}
}
func (m *SupportedLanguagesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SupportedLanguagesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SupportedLanguagesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SupportedLanguagesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SupportedLanguagesResponse.Merge(m, src)
}
func (m *SupportedLanguagesResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SupportedLanguagesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SupportedLanguagesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SupportedLanguagesResponse proto.InternalMessageInfo

// ErrorDetails adds bblfsh-specific information to gRPC errors (google.rpc.Status).
type ErrorDetails struct {
	// Types that are valid to be assigned to Reason:
	//	*ErrorDetails_InvalidFileEncoding
	//	*ErrorDetails_UnsupportedLanguage
	//	*ErrorDetails_CannotDetectLanguage
	//	*ErrorDetails_UnsupportedTransformMode
	//	*ErrorDetails_TransformFailure
	//	*ErrorDetails_DriverFailure
	Reason               isErrorDetails_Reason `protobuf_oneof:"reason"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *ErrorDetails) Reset()         { *m = ErrorDetails{} }
func (m *ErrorDetails) String() string { return proto.CompactTextString(m) }
func (*ErrorDetails) ProtoMessage()    {}
func (*ErrorDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_521003751d596b5e, []int{9}
}
func (m *ErrorDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ErrorDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ErrorDetails.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ErrorDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ErrorDetails.Merge(m, src)
}
func (m *ErrorDetails) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ErrorDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_ErrorDetails.DiscardUnknown(m)
}

var xxx_messageInfo_ErrorDetails proto.InternalMessageInfo

type isErrorDetails_Reason interface {
	isErrorDetails_Reason()
	MarshalTo([]byte) (int, error)
	ProtoSize() int
}

type ErrorDetails_InvalidFileEncoding struct {
	InvalidFileEncoding bool `protobuf:"varint,1,opt,name=invalid_file_encoding,json=invalidFileEncoding,proto3,oneof"`
}
type ErrorDetails_UnsupportedLanguage struct {
	UnsupportedLanguage string `protobuf:"bytes,2,opt,name=unsupported_language,json=unsupportedLanguage,proto3,oneof"`
}
type ErrorDetails_CannotDetectLanguage struct {
	CannotDetectLanguage bool `protobuf:"varint,3,opt,name=cannot_detect_language,json=cannotDetectLanguage,proto3,oneof"`
}
type ErrorDetails_UnsupportedTransformMode struct {
	UnsupportedTransformMode bool `protobuf:"varint,4,opt,name=unsupported_transform_mode,json=unsupportedTransformMode,proto3,oneof"`
}
type ErrorDetails_TransformFailure struct {
	TransformFailure bool `protobuf:"varint,5,opt,name=transform_failure,json=transformFailure,proto3,oneof"`
}
type ErrorDetails_DriverFailure struct {
	DriverFailure bool `protobuf:"varint,6,opt,name=driver_failure,json=driverFailure,proto3,oneof"`
}

func (*ErrorDetails_InvalidFileEncoding) isErrorDetails_Reason()      {}
func (*ErrorDetails_UnsupportedLanguage) isErrorDetails_Reason()      {}
func (*ErrorDetails_CannotDetectLanguage) isErrorDetails_Reason()     {}
func (*ErrorDetails_UnsupportedTransformMode) isErrorDetails_Reason() {}
func (*ErrorDetails_TransformFailure) isErrorDetails_Reason()         {}
func (*ErrorDetails_DriverFailure) isErrorDetails_Reason()            {}

func (m *ErrorDetails) GetReason() isErrorDetails_Reason {
	if m != nil {
		return m.Reason
	}
	return nil
}

func (m *ErrorDetails) GetInvalidFileEncoding() bool {
	if x, ok := m.GetReason().(*ErrorDetails_InvalidFileEncoding); ok {
		return x.InvalidFileEncoding
	}
	return false
}

func (m *ErrorDetails) GetUnsupportedLanguage() string {
	if x, ok := m.GetReason().(*ErrorDetails_UnsupportedLanguage); ok {
		return x.UnsupportedLanguage
	}
	return ""
}

func (m *ErrorDetails) GetCannotDetectLanguage() bool {
	if x, ok := m.GetReason().(*ErrorDetails_CannotDetectLanguage); ok {
		return x.CannotDetectLanguage
	}
	return false
}

func (m *ErrorDetails) GetUnsupportedTransformMode() bool {
	if x, ok := m.GetReason().(*ErrorDetails_UnsupportedTransformMode); ok {
		return x.UnsupportedTransformMode
	}
	return false
}

func (m *ErrorDetails) GetTransformFailure() bool {
	if x, ok := m.GetReason().(*ErrorDetails_TransformFailure); ok {
		return x.TransformFailure
	}
	return false
}

func (m *ErrorDetails) GetDriverFailure() bool {
	if x, ok := m.GetReason().(*ErrorDetails_DriverFailure); ok {
		return x.DriverFailure
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ErrorDetails) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ErrorDetails_OneofMarshaler, _ErrorDetails_OneofUnmarshaler, _ErrorDetails_OneofSizer, []interface{}{
		(*ErrorDetails_InvalidFileEncoding)(nil),
		(*ErrorDetails_UnsupportedLanguage)(nil),
		(*ErrorDetails_CannotDetectLanguage)(nil),
		(*ErrorDetails_UnsupportedTransformMode)(nil),
		(*ErrorDetails_TransformFailure)(nil),
		(*ErrorDetails_DriverFailure)(nil),
	}
}

func _ErrorDetails_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ErrorDetails)
	// reason
	switch x := m.Reason.(type) {
	case *ErrorDetails_InvalidFileEncoding:
		t := uint64(0)
		if x.InvalidFileEncoding {
			t = 1
		}
		_ = b.EncodeVarint(1<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *ErrorDetails_UnsupportedLanguage:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.UnsupportedLanguage)
	case *ErrorDetails_CannotDetectLanguage:
		t := uint64(0)
		if x.CannotDetectLanguage {
			t = 1
		}
		_ = b.EncodeVarint(3<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *ErrorDetails_UnsupportedTransformMode:
		t := uint64(0)
		if x.UnsupportedTransformMode {
			t = 1
		}
		_ = b.EncodeVarint(4<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *ErrorDetails_TransformFailure:
		t := uint64(0)
		if x.TransformFailure {
			t = 1
		}
		_ = b.EncodeVarint(5<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *ErrorDetails_DriverFailure:
		t := uint64(0)
		if x.DriverFailure {
			t = 1
		}
		_ = b.EncodeVarint(6<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("ErrorDetails.Reason has unexpected type %T", x)
	}
	return nil
}

func _ErrorDetails_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ErrorDetails)
	switch tag {
	case 1: // reason.invalid_file_encoding
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Reason = &ErrorDetails_InvalidFileEncoding{x != 0}
		return true, err
	case 2: // reason.unsupported_language
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Reason = &ErrorDetails_UnsupportedLanguage{x}
		return true, err
	case 3: // reason.cannot_detect_language
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Reason = &ErrorDetails_CannotDetectLanguage{x != 0}
		return true, err
	case 4: // reason.unsupported_transform_mode
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Reason = &ErrorDetails_UnsupportedTransformMode{x != 0}
		return true, err
	case 5: // reason.transform_failure
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Reason = &ErrorDetails_TransformFailure{x != 0}
		return true, err
	case 6: // reason.driver_failure
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Reason = &ErrorDetails_DriverFailure{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _ErrorDetails_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ErrorDetails)
	// reason
	switch x := m.Reason.(type) {
	case *ErrorDetails_InvalidFileEncoding:
		n += 1 // tag and wire
		n += 1
	case *ErrorDetails_UnsupportedLanguage:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.UnsupportedLanguage)))
		n += len(x.UnsupportedLanguage)
	case *ErrorDetails_CannotDetectLanguage:
		n += 1 // tag and wire
		n += 1
	case *ErrorDetails_UnsupportedTransformMode:
		n += 1 // tag and wire
		n += 1
	case *ErrorDetails_TransformFailure:
		n += 1 // tag and wire
		n += 1
	case *ErrorDetails_DriverFailure:
		n += 1 // tag and wire
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func (*ErrorDetails) XXX_MessageName() string {
	return "gopkg.in.bblfsh.sdk.v2.protocol.ErrorDetails"
}
func init() {
	proto.RegisterEnum("gopkg.in.bblfsh.sdk.v2.protocol.Mode", Mode_name, Mode_value)
	golang_proto.RegisterEnum("gopkg.in.bblfsh.sdk.v2.protocol.Mode", Mode_name, Mode_value)
	proto.RegisterEnum("gopkg.in.bblfsh.sdk.v2.protocol.DevelopmentStatus", DevelopmentStatus_name, DevelopmentStatus_value)
	golang_proto.RegisterEnum("gopkg.in.bblfsh.sdk.v2.protocol.DevelopmentStatus", DevelopmentStatus_name, DevelopmentStatus_value)
	proto.RegisterType((*ParseRequest)(nil), "gopkg.in.bblfsh.sdk.v2.protocol.ParseRequest")
	golang_proto.RegisterType((*ParseRequest)(nil), "gopkg.in.bblfsh.sdk.v2.protocol.ParseRequest")
	proto.RegisterType((*ParseResponse)(nil), "gopkg.in.bblfsh.sdk.v2.protocol.ParseResponse")
	golang_proto.RegisterType((*ParseResponse)(nil), "gopkg.in.bblfsh.sdk.v2.protocol.ParseResponse")
	proto.RegisterType((*ParseError)(nil), "gopkg.in.bblfsh.sdk.v2.protocol.ParseError")
	golang_proto.RegisterType((*ParseError)(nil), "gopkg.in.bblfsh.sdk.v2.protocol.ParseError")
	proto.RegisterType((*Version)(nil), "gopkg.in.bblfsh.sdk.v2.protocol.Version")
	golang_proto.RegisterType((*Version)(nil), "gopkg.in.bblfsh.sdk.v2.protocol.Version")
	proto.RegisterType((*Manifest)(nil), "gopkg.in.bblfsh.sdk.v2.protocol.Manifest")
	golang_proto.RegisterType((*Manifest)(nil), "gopkg.in.bblfsh.sdk.v2.protocol.Manifest")
	proto.RegisterType((*VersionRequest)(nil), "gopkg.in.bblfsh.sdk.v2.protocol.VersionRequest")
	golang_proto.RegisterType((*VersionRequest)(nil), "gopkg.in.bblfsh.sdk.v2.protocol.VersionRequest")
	proto.RegisterType((*VersionResponse)(nil), "gopkg.in.bblfsh.sdk.v2.protocol.VersionResponse")
	golang_proto.RegisterType((*VersionResponse)(nil), "gopkg.in.bblfsh.sdk.v2.protocol.VersionResponse")
	proto.RegisterType((*SupportedLanguagesRequest)(nil), "gopkg.in.bblfsh.sdk.v2.protocol.SupportedLanguagesRequest")
	golang_proto.RegisterType((*SupportedLanguagesRequest)(nil), "gopkg.in.bblfsh.sdk.v2.protocol.SupportedLanguagesRequest")
	proto.RegisterType((*SupportedLanguagesResponse)(nil), "gopkg.in.bblfsh.sdk.v2.protocol.SupportedLanguagesResponse")
	golang_proto.RegisterType((*SupportedLanguagesResponse)(nil), "gopkg.in.bblfsh.sdk.v2.protocol.SupportedLanguagesResponse")
	proto.RegisterType((*ErrorDetails)(nil), "gopkg.in.bblfsh.sdk.v2.protocol.ErrorDetails")
	golang_proto.RegisterType((*ErrorDetails)(nil), "gopkg.in.bblfsh.sdk.v2.protocol.ErrorDetails")
}

func init() { proto.RegisterFile("driver.proto", fileDescriptor_521003751d596b5e) }
func init() { golang_proto.RegisterFile("driver.proto", fileDescriptor_521003751d596b5e) }

var fileDescriptor_521003751d596b5e = []byte{
	// 1019 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x54, 0xcf, 0x6f, 0xe3, 0xc4,
	0x17, 0x8f, 0xd3, 0x34, 0x4d, 0x5e, 0xd3, 0xae, 0x77, 0xbe, 0xfb, 0xad, 0x8c, 0x41, 0xa9, 0xb1,
	0x84, 0x28, 0x8b, 0xea, 0xa2, 0x2c, 0x42, 0xa2, 0x48, 0x48, 0x4e, 0xe3, 0x6e, 0x8b, 0x92, 0x34,
	0x72, 0xd2, 0x1e, 0xb8, 0x44, 0x93, 0x78, 0x92, 0x5a, 0xeb, 0x78, 0x82, 0x67, 0x1c, 0x71, 0xe4,
	0xc0, 0x01, 0x45, 0x42, 0xda, 0x3b, 0x8a, 0x40, 0xfc, 0x25, 0x1c, 0x7b, 0xe4, 0xca, 0x81, 0x5f,
	0xdd, 0x7f, 0x04, 0x79, 0xc6, 0x4e, 0xba, 0x5a, 0xd8, 0x54, 0x7b, 0x9b, 0x37, 0x9f, 0xf7, 0x99,
	0xf7, 0x99, 0xf7, 0x0b, 0x2a, 0x5e, 0xe4, 0xcf, 0x48, 0x64, 0x4d, 0x23, 0xca, 0x29, 0xda, 0x1f,
	0xd3, 0xe9, 0xb3, 0xb1, 0xe5, 0x87, 0xd6, 0x60, 0x10, 0x8c, 0xd8, 0xb5, 0xc5, 0xbc, 0x67, 0xd6,
	0xac, 0x26, 0xd1, 0x21, 0x0d, 0xf4, 0xc3, 0xb1, 0xcf, 0xaf, 0xe3, 0x81, 0x35, 0xa4, 0x93, 0xa3,
	0x31, 0x1d, 0xd3, 0x23, 0x81, 0x0c, 0xe2, 0x91, 0xb0, 0x84, 0x21, 0x4e, 0x92, 0xa1, 0xef, 0x8f,
	0x29, 0x1d, 0x07, 0x64, 0xe5, 0xc5, 0xfd, 0x09, 0x61, 0x1c, 0x4f, 0xa6, 0xd2, 0xc1, 0xfc, 0x41,
	0x81, 0x4a, 0x07, 0x47, 0x8c, 0xb8, 0xe4, 0xab, 0x98, 0x30, 0x8e, 0x34, 0xd8, 0x1a, 0xd2, 0x90,
	0x93, 0x90, 0x6b, 0x8a, 0xa1, 0x1c, 0x94, 0xdd, 0xcc, 0x44, 0x3a, 0x94, 0x02, 0x1c, 0x8e, 0x63,
	0x3c, 0x26, 0x5a, 0x5e, 0x40, 0x4b, 0x3b, 0xc1, 0x46, 0x7e, 0x40, 0x42, 0x3c, 0x21, 0xda, 0x86,
	0xc4, 0x32, 0x1b, 0x7d, 0x0a, 0x85, 0x09, 0xf5, 0x88, 0x56, 0x30, 0x94, 0x83, 0xdd, 0xda, 0x7b,
	0xd6, 0x9a, 0x2f, 0x5a, 0x2d, 0xea, 0x11, 0x57, 0x50, 0xcc, 0x6f, 0x15, 0xd8, 0x49, 0xd5, 0xb1,
	0x29, 0x0d, 0x19, 0x41, 0x08, 0x0a, 0x31, 0x66, 0x52, 0x5b, 0xc5, 0x15, 0xe7, 0xd7, 0x0a, 0x3b,
	0x81, 0x22, 0x89, 0x22, 0x1a, 0x31, 0x6d, 0xc3, 0xd8, 0x38, 0xd8, 0xae, 0x7d, 0xb8, 0x36, 0xbc,
	0x88, 0xe7, 0x24, 0x1c, 0x37, 0xa5, 0x9a, 0x06, 0xc0, 0xea, 0x36, 0x91, 0xc0, 0xc9, 0xd7, 0x59,
	0x7a, 0xc4, 0xd9, 0xec, 0xc3, 0xd6, 0x15, 0x89, 0x98, 0x4f, 0xc3, 0x24, 0x81, 0x33, 0x79, 0xcc,
	0x12, 0x98, 0x9a, 0xe8, 0x18, 0x36, 0x07, 0xb1, 0x1f, 0x78, 0x42, 0xe4, 0x76, 0x4d, 0xb7, 0x64,
	0x71, 0xac, 0xac, 0x38, 0x56, 0x2f, 0x2b, 0x4e, 0xbd, 0x74, 0xf3, 0xc7, 0x7e, 0xee, 0xf9, 0x9f,
	0xfb, 0x8a, 0x2b, 0x29, 0xe6, 0x37, 0x79, 0x28, 0xb5, 0x70, 0xe8, 0x8f, 0x92, 0x1a, 0x21, 0x28,
	0x88, 0x4c, 0xa7, 0x0a, 0x44, 0x96, 0x5f, 0x97, 0x04, 0x0d, 0xb6, 0x70, 0xe0, 0x63, 0x46, 0x64,
	0x16, 0xca, 0x6e, 0x66, 0xa2, 0xfa, 0x4a, 0x6c, 0x41, 0x88, 0x3a, 0x58, 0x9b, 0x9f, 0xf4, 0x9f,
	0xab, 0x6f, 0x7d, 0x01, 0x45, 0xc6, 0x31, 0x8f, 0x99, 0xb6, 0x29, 0x2a, 0x5c, 0x5b, 0xfb, 0x44,
	0x83, 0xcc, 0x48, 0x40, 0xa7, 0x13, 0x12, 0xf2, 0xae, 0x60, 0xba, 0xe9, 0x0b, 0xa2, 0x8f, 0x08,
	0xe6, 0x71, 0x44, 0x98, 0x56, 0x14, 0x52, 0x97, 0xb6, 0xa9, 0xc2, 0x6e, 0x16, 0x5b, 0xf6, 0xaa,
	0x79, 0x09, 0x0f, 0x96, 0x37, 0x69, 0x7f, 0xd4, 0x5f, 0xce, 0xfe, 0x9b, 0x7c, 0xc8, 0x7c, 0x1b,
	0xde, 0xea, 0xc6, 0xd3, 0x29, 0x8d, 0x38, 0xf1, 0x9a, 0x69, 0x0e, 0x59, 0x16, 0x93, 0x80, 0xfe,
	0x6f, 0x60, 0x1a, 0xfe, 0x29, 0x94, 0xb3, 0xac, 0x33, 0x4d, 0x11, 0x1d, 0xf7, 0xc1, 0xfa, 0x86,
	0x4f, 0xeb, 0xea, 0xae, 0xb8, 0xe6, 0x6f, 0x79, 0xa8, 0x88, 0x76, 0x6b, 0x10, 0x8e, 0xfd, 0x80,
	0xa1, 0x8f, 0xe1, 0xff, 0x7e, 0x38, 0xc3, 0x81, 0xef, 0xf5, 0x93, 0xc9, 0xea, 0x93, 0x70, 0x48,
	0x3d, 0x3f, 0x1c, 0x8b, 0x6f, 0x96, 0xce, 0x72, 0xee, 0xff, 0x52, 0xf8, 0xd4, 0x0f, 0x88, 0x93,
	0x82, 0xe8, 0x09, 0x3c, 0x8a, 0x43, 0x96, 0xe9, 0xed, 0xbf, 0xdc, 0x21, 0x09, 0xe9, 0x0e, 0x9a,
	0xfd, 0x06, 0x7d, 0x02, 0x7b, 0x43, 0x1c, 0x86, 0x94, 0xf7, 0x3d, 0xc2, 0xc9, 0x90, 0xaf, 0x68,
	0x1b, 0x69, 0xac, 0x47, 0x12, 0x6f, 0x08, 0x78, 0xc9, 0xfb, 0x1c, 0xf4, 0xbb, 0xc1, 0x78, 0x84,
	0x43, 0x36, 0xa2, 0xd1, 0xa4, 0xbf, 0x1c, 0xff, 0x84, 0xab, 0xdd, 0xf1, 0xe9, 0x65, 0x2e, 0xc9,
	0xcc, 0xa3, 0x43, 0x78, 0xb8, 0xe2, 0x8c, 0xb0, 0x1f, 0xc4, 0x11, 0x11, 0x3d, 0x95, 0xd0, 0xd4,
	0x25, 0x74, 0x2a, 0x11, 0xf4, 0x3e, 0xec, 0xca, 0xdd, 0xb9, 0xf4, 0x2d, 0xa6, 0xbe, 0x3b, 0xf2,
	0x3e, 0x75, 0x3c, 0x2e, 0x7c, 0xf7, 0xf3, 0xbe, 0x52, 0x2f, 0x41, 0x31, 0x22, 0x98, 0xd1, 0xf0,
	0xf1, 0x8f, 0x0a, 0x14, 0x44, 0xc0, 0x77, 0xa1, 0xd2, 0x70, 0x4e, 0xed, 0xcb, 0x66, 0xaf, 0xdf,
	0xba, 0x68, 0x38, 0x6a, 0x4e, 0x7f, 0x30, 0x5f, 0x18, 0xdb, 0x0d, 0x32, 0xc2, 0x71, 0xc0, 0x85,
	0xcb, 0x1e, 0x14, 0xdb, 0x76, 0xef, 0xfc, 0xca, 0x51, 0x15, 0x1d, 0xe6, 0x0b, 0xa3, 0xd8, 0xc6,
	0xdc, 0x9f, 0x11, 0x64, 0x42, 0xa5, 0xe3, 0x3a, 0x1d, 0xf7, 0xe2, 0xc4, 0xe9, 0x76, 0x9d, 0x86,
	0x9a, 0xd7, 0xd5, 0xf9, 0xc2, 0xa8, 0x74, 0x22, 0x32, 0x8d, 0xe8, 0x90, 0x30, 0x46, 0x3c, 0xf4,
	0x0e, 0x94, 0xed, 0x76, 0xfb, 0xa2, 0x67, 0xf7, 0x9c, 0x86, 0x5a, 0xd0, 0x77, 0xe6, 0x0b, 0xa3,
	0x6c, 0x27, 0x79, 0xc3, 0x9c, 0x78, 0x49, 0xab, 0x77, 0x9d, 0x96, 0xdd, 0xee, 0x9d, 0x9f, 0xa8,
	0x25, 0xbd, 0x32, 0x5f, 0x18, 0xa5, 0x2e, 0x99, 0xe0, 0x90, 0xfb, 0xc3, 0xc7, 0xbf, 0x2b, 0xf0,
	0xf0, 0x95, 0x21, 0x41, 0xd5, 0x44, 0xee, 0x55, 0xff, 0xbc, 0x6d, 0x9f, 0x08, 0x45, 0x39, 0xc9,
	0x3a, 0x0f, 0xf1, 0x50, 0x68, 0x4a, 0xf1, 0x4e, 0xd3, 0x6e, 0xb7, 0xcf, 0xdb, 0x4f, 0x55, 0x45,
	0xe2, 0x9d, 0x00, 0x87, 0x61, 0xd2, 0x0c, 0x19, 0xee, 0x3a, 0x76, 0xb3, 0x73, 0x66, 0xab, 0xf9,
	0x14, 0x8f, 0x88, 0x1d, 0x4c, 0xaf, 0x31, 0xd2, 0xa0, 0x9c, 0xe0, 0x12, 0xdc, 0xd0, 0xcb, 0xf3,
	0x85, 0xb1, 0x29, 0x91, 0x3d, 0x28, 0x25, 0x48, 0xdd, 0xe9, 0xd9, 0x6a, 0x41, 0x2f, 0xcd, 0x17,
	0x46, 0xa1, 0x4e, 0x38, 0x46, 0x3a, 0x40, 0x72, 0xdf, 0xed, 0xd9, 0xf5, 0xa6, 0xa3, 0x6e, 0xca,
	0x0c, 0x75, 0x39, 0x1e, 0x04, 0x24, 0xc3, 0x5a, 0x76, 0xef, 0xd2, 0x75, 0xd4, 0xa2, 0xc4, 0x5a,
	0x62, 0x96, 0x6b, 0x53, 0x28, 0x36, 0x44, 0x89, 0xd0, 0x08, 0x36, 0xc5, 0x6a, 0x45, 0x87, 0xf7,
	0x5b, 0xcc, 0xe9, 0x18, 0xea, 0xd6, 0x7d, 0xdd, 0xe5, 0x60, 0xd6, 0x9e, 0xe7, 0x01, 0x64, 0xc8,
	0x33, 0xca, 0x38, 0x8a, 0x60, 0xa7, 0x4b, 0xa2, 0x19, 0x89, 0xb2, 0xad, 0x7d, 0x74, 0xef, 0x35,
	0x91, 0x0a, 0xf8, 0xe8, 0xfe, 0x84, 0x74, 0x37, 0x7c, 0xaf, 0x00, 0x7a, 0x75, 0x75, 0xa0, 0xe3,
	0xb5, 0x0f, 0xfd, 0xe7, 0x32, 0xd2, 0x3f, 0x7b, 0x23, 0xae, 0xd4, 0x53, 0x37, 0x6f, 0xfe, 0xae,
	0xe6, 0x6e, 0x6e, 0xab, 0xca, 0xaf, 0xb7, 0x55, 0xe5, 0xaf, 0xdb, 0x6a, 0xee, 0xa7, 0x17, 0x55,
	0xe5, 0x97, 0x17, 0x55, 0xe5, 0xcb, 0x52, 0x46, 0x1f, 0x14, 0xc5, 0xe9, 0xc9, 0x3f, 0x01, 0x00,
	0x00, 0xff, 0xff, 0xf2, 0x4f, 0xc7, 0x15, 0xa6, 0x08, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// DriverClient is the client API for Driver service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type DriverClient interface {
	// Parse returns an UAST for a given source file.
	Parse(ctx context.Context, in *ParseRequest, opts ...grpc.CallOption) (*ParseResponse, error)
}

type driverClient struct {
	cc *grpc.ClientConn
}

func NewDriverClient(cc *grpc.ClientConn) DriverClient {
	return &driverClient{cc}
}

func (c *driverClient) Parse(ctx context.Context, in *ParseRequest, opts ...grpc.CallOption) (*ParseResponse, error) {
	out := new(ParseResponse)
	err := c.cc.Invoke(ctx, "/gopkg.in.bblfsh.sdk.v2.protocol.Driver/Parse", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DriverServer is the server API for Driver service.
type DriverServer interface {
	// Parse returns an UAST for a given source file.
	Parse(context.Context, *ParseRequest) (*ParseResponse, error)
}

// UnimplementedDriverServer can be embedded to have forward compatible implementations.
type UnimplementedDriverServer struct {
}

func (*UnimplementedDriverServer) Parse(ctx context.Context, req *ParseRequest) (*ParseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Parse not implemented")
}

func RegisterDriverServer(s *grpc.Server, srv DriverServer) {
	s.RegisterService(&_Driver_serviceDesc, srv)
}

func _Driver_Parse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ParseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DriverServer).Parse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gopkg.in.bblfsh.sdk.v2.protocol.Driver/Parse",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DriverServer).Parse(ctx, req.(*ParseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Driver_serviceDesc = grpc.ServiceDesc{
	ServiceName: "gopkg.in.bblfsh.sdk.v2.protocol.Driver",
	HandlerType: (*DriverServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Parse",
			Handler:    _Driver_Parse_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "driver.proto",
}

// DriverHostClient is the client API for DriverHost service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type DriverHostClient interface {
	// ServerVersion returns version information of this server.
	ServerVersion(ctx context.Context, in *VersionRequest, opts ...grpc.CallOption) (*VersionResponse, error)
	// SupportedLanguages returns a list of languages supported by the server.
	SupportedLanguages(ctx context.Context, in *SupportedLanguagesRequest, opts ...grpc.CallOption) (*SupportedLanguagesResponse, error)
}

type driverHostClient struct {
	cc *grpc.ClientConn
}

func NewDriverHostClient(cc *grpc.ClientConn) DriverHostClient {
	return &driverHostClient{cc}
}

func (c *driverHostClient) ServerVersion(ctx context.Context, in *VersionRequest, opts ...grpc.CallOption) (*VersionResponse, error) {
	out := new(VersionResponse)
	err := c.cc.Invoke(ctx, "/gopkg.in.bblfsh.sdk.v2.protocol.DriverHost/ServerVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *driverHostClient) SupportedLanguages(ctx context.Context, in *SupportedLanguagesRequest, opts ...grpc.CallOption) (*SupportedLanguagesResponse, error) {
	out := new(SupportedLanguagesResponse)
	err := c.cc.Invoke(ctx, "/gopkg.in.bblfsh.sdk.v2.protocol.DriverHost/SupportedLanguages", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DriverHostServer is the server API for DriverHost service.
type DriverHostServer interface {
	// ServerVersion returns version information of this server.
	ServerVersion(context.Context, *VersionRequest) (*VersionResponse, error)
	// SupportedLanguages returns a list of languages supported by the server.
	SupportedLanguages(context.Context, *SupportedLanguagesRequest) (*SupportedLanguagesResponse, error)
}

// UnimplementedDriverHostServer can be embedded to have forward compatible implementations.
type UnimplementedDriverHostServer struct {
}

func (*UnimplementedDriverHostServer) ServerVersion(ctx context.Context, req *VersionRequest) (*VersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ServerVersion not implemented")
}
func (*UnimplementedDriverHostServer) SupportedLanguages(ctx context.Context, req *SupportedLanguagesRequest) (*SupportedLanguagesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SupportedLanguages not implemented")
}

func RegisterDriverHostServer(s *grpc.Server, srv DriverHostServer) {
	s.RegisterService(&_DriverHost_serviceDesc, srv)
}

func _DriverHost_ServerVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DriverHostServer).ServerVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gopkg.in.bblfsh.sdk.v2.protocol.DriverHost/ServerVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DriverHostServer).ServerVersion(ctx, req.(*VersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DriverHost_SupportedLanguages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SupportedLanguagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DriverHostServer).SupportedLanguages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gopkg.in.bblfsh.sdk.v2.protocol.DriverHost/SupportedLanguages",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DriverHostServer).SupportedLanguages(ctx, req.(*SupportedLanguagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _DriverHost_serviceDesc = grpc.ServiceDesc{
	ServiceName: "gopkg.in.bblfsh.sdk.v2.protocol.DriverHost",
	HandlerType: (*DriverHostServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ServerVersion",
			Handler:    _DriverHost_ServerVersion_Handler,
		},
		{
			MethodName: "SupportedLanguages",
			Handler:    _DriverHost_SupportedLanguages_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "driver.proto",
}

func (m *ParseRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParseRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ParseRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Mode != 0 {
		i = encodeVarintDriver(dAtA, i, uint64(m.Mode))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Filename) > 0 {
		i -= len(m.Filename)
		copy(dAtA[i:], m.Filename)
		i = encodeVarintDriver(dAtA, i, uint64(len(m.Filename)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Language) > 0 {
		i -= len(m.Language)
		copy(dAtA[i:], m.Language)
		i = encodeVarintDriver(dAtA, i, uint64(len(m.Language)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Content) > 0 {
		i -= len(m.Content)
		copy(dAtA[i:], m.Content)
		i = encodeVarintDriver(dAtA, i, uint64(len(m.Content)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ParseResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParseResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ParseResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Errors) > 0 {
		for iNdEx := len(m.Errors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Errors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDriver(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Language) > 0 {
		i -= len(m.Language)
		copy(dAtA[i:], m.Language)
		i = encodeVarintDriver(dAtA, i, uint64(len(m.Language)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Uast) > 0 {
		i -= len(m.Uast)
		copy(dAtA[i:], m.Uast)
		i = encodeVarintDriver(dAtA, i, uint64(len(m.Uast)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ParseError) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParseError) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ParseError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Text) > 0 {
		i -= len(m.Text)
		copy(dAtA[i:], m.Text)
		i = encodeVarintDriver(dAtA, i, uint64(len(m.Text)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Version) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Version) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Version) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	n1, err1 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Build, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Build):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintDriver(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x12
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintDriver(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Manifest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Manifest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Manifest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Features) > 0 {
		for iNdEx := len(m.Features) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Features[iNdEx])
			copy(dAtA[i:], m.Features[iNdEx])
			i = encodeVarintDriver(dAtA, i, uint64(len(m.Features[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Status != 0 {
		i = encodeVarintDriver(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x28
	}
	if m.Version != nil {
		{
			size, err := m.Version.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDriver(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Aliases) > 0 {
		for iNdEx := len(m.Aliases) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Aliases[iNdEx])
			copy(dAtA[i:], m.Aliases[iNdEx])
			i = encodeVarintDriver(dAtA, i, uint64(len(m.Aliases[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Language) > 0 {
		i -= len(m.Language)
		copy(dAtA[i:], m.Language)
		i = encodeVarintDriver(dAtA, i, uint64(len(m.Language)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintDriver(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VersionRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VersionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VersionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *VersionResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VersionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VersionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Version != nil {
		{
			size, err := m.Version.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDriver(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SupportedLanguagesRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SupportedLanguagesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SupportedLanguagesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *SupportedLanguagesResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SupportedLanguagesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SupportedLanguagesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Languages) > 0 {
		for iNdEx := len(m.Languages) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Languages[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDriver(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ErrorDetails) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ErrorDetails) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ErrorDetails) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Reason != nil {
		{
			size := m.Reason.ProtoSize()
			i -= size
			if _, err := m.Reason.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ErrorDetails_InvalidFileEncoding) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.ProtoSize()])
}

func (m *ErrorDetails_InvalidFileEncoding) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.InvalidFileEncoding {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}
func (m *ErrorDetails_UnsupportedLanguage) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.ProtoSize()])
}

func (m *ErrorDetails_UnsupportedLanguage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.UnsupportedLanguage)
	copy(dAtA[i:], m.UnsupportedLanguage)
	i = encodeVarintDriver(dAtA, i, uint64(len(m.UnsupportedLanguage)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *ErrorDetails_CannotDetectLanguage) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.ProtoSize()])
}

func (m *ErrorDetails_CannotDetectLanguage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.CannotDetectLanguage {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *ErrorDetails_UnsupportedTransformMode) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.ProtoSize()])
}

func (m *ErrorDetails_UnsupportedTransformMode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.UnsupportedTransformMode {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x20
	return len(dAtA) - i, nil
}
func (m *ErrorDetails_TransformFailure) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.ProtoSize()])
}

func (m *ErrorDetails_TransformFailure) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.TransformFailure {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x28
	return len(dAtA) - i, nil
}
func (m *ErrorDetails_DriverFailure) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.ProtoSize()])
}

func (m *ErrorDetails_DriverFailure) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.DriverFailure {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x30
	return len(dAtA) - i, nil
}
func encodeVarintDriver(dAtA []byte, offset int, v uint64) int {
	offset -= sovDriver(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ParseRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovDriver(uint64(l))
	}
	l = len(m.Language)
	if l > 0 {
		n += 1 + l + sovDriver(uint64(l))
	}
	l = len(m.Filename)
	if l > 0 {
		n += 1 + l + sovDriver(uint64(l))
	}
	if m.Mode != 0 {
		n += 1 + sovDriver(uint64(m.Mode))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ParseResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Uast)
	if l > 0 {
		n += 1 + l + sovDriver(uint64(l))
	}
	l = len(m.Language)
	if l > 0 {
		n += 1 + l + sovDriver(uint64(l))
	}
	if len(m.Errors) > 0 {
		for _, e := range m.Errors {
			l = e.ProtoSize()
			n += 1 + l + sovDriver(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ParseError) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovDriver(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Version) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovDriver(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Build)
	n += 1 + l + sovDriver(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Manifest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDriver(uint64(l))
	}
	l = len(m.Language)
	if l > 0 {
		n += 1 + l + sovDriver(uint64(l))
	}
	if len(m.Aliases) > 0 {
		for _, s := range m.Aliases {
			l = len(s)
			n += 1 + l + sovDriver(uint64(l))
		}
	}
	if m.Version != nil {
		l = m.Version.ProtoSize()
		n += 1 + l + sovDriver(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovDriver(uint64(m.Status))
	}
	if len(m.Features) > 0 {
		for _, s := range m.Features {
			l = len(s)
			n += 1 + l + sovDriver(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VersionRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VersionResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != nil {
		l = m.Version.ProtoSize()
		n += 1 + l + sovDriver(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SupportedLanguagesRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SupportedLanguagesResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Languages) > 0 {
		for _, e := range m.Languages {
			l = e.ProtoSize()
			n += 1 + l + sovDriver(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ErrorDetails) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Reason != nil {
		n += m.Reason.ProtoSize()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ErrorDetails_InvalidFileEncoding) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *ErrorDetails_UnsupportedLanguage) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UnsupportedLanguage)
	n += 1 + l + sovDriver(uint64(l))
	return n
}
func (m *ErrorDetails_CannotDetectLanguage) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *ErrorDetails_UnsupportedTransformMode) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *ErrorDetails_TransformFailure) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *ErrorDetails_DriverFailure) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}

func sovDriver(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDriver(x uint64) (n int) {
	return sovDriver(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ParseRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDriver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParseRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParseRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDriver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDriver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDriver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDriver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDriver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDriver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filename", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDriver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDriver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDriver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filename = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDriver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= Mode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDriver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDriver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDriver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParseResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDriver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParseResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParseResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uast", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDriver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDriver
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDriver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uast = append(m.Uast[:0], dAtA[iNdEx:postIndex]...)
			if m.Uast == nil {
				m.Uast = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDriver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDriver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDriver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDriver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDriver
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDriver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Errors = append(m.Errors, &ParseError{})
			if err := m.Errors[len(m.Errors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDriver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDriver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDriver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParseError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDriver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParseError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParseError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDriver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDriver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDriver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDriver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDriver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDriver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Version) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDriver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Version: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Version: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDriver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDriver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDriver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Build", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDriver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDriver
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDriver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Build, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDriver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDriver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDriver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Manifest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDriver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Manifest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Manifest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDriver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDriver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDriver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDriver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDriver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDriver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aliases", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDriver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDriver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDriver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Aliases = append(m.Aliases, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDriver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDriver
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDriver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Version == nil {
				m.Version = &Version{}
			}
			if err := m.Version.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDriver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= DevelopmentStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Features", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDriver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDriver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDriver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Features = append(m.Features, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDriver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDriver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDriver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VersionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDriver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VersionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VersionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDriver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDriver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDriver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VersionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDriver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VersionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VersionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDriver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDriver
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDriver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Version == nil {
				m.Version = &Version{}
			}
			if err := m.Version.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDriver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDriver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDriver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SupportedLanguagesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDriver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SupportedLanguagesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SupportedLanguagesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDriver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDriver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDriver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SupportedLanguagesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDriver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SupportedLanguagesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SupportedLanguagesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Languages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDriver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDriver
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDriver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Languages = append(m.Languages, &Manifest{})
			if err := m.Languages[len(m.Languages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDriver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDriver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDriver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ErrorDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDriver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ErrorDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ErrorDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvalidFileEncoding", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDriver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Reason = &ErrorDetails_InvalidFileEncoding{b}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnsupportedLanguage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDriver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDriver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDriver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = &ErrorDetails_UnsupportedLanguage{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CannotDetectLanguage", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDriver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Reason = &ErrorDetails_CannotDetectLanguage{b}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnsupportedTransformMode", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDriver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Reason = &ErrorDetails_UnsupportedTransformMode{b}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransformFailure", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDriver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Reason = &ErrorDetails_TransformFailure{b}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DriverFailure", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDriver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Reason = &ErrorDetails_DriverFailure{b}
		default:
			iNdEx = preIndex
			skippy, err := skipDriver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDriver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDriver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDriver(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDriver
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDriver
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDriver
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDriver
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthDriver
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowDriver
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipDriver(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthDriver
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthDriver = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDriver   = fmt.Errorf("proto: integer overflow")
)
