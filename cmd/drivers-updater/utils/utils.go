package utils

import (
	"context"
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"strings"

	"bitbucket.org/creachadair/shell"
	"github.com/bblfsh/sdk/v3/driver/manifest/discovery"
	"github.com/google/go-github/v27/github"
	"golang.org/x/oauth2"
	"gopkg.in/src-d/go-errors.v1"
	"gopkg.in/src-d/go-log.v1"
)

const (
	commitMsg = "autogenerated changes"
	org       = "bblfsh"
)

var (
	errFailedPrepareBranch = errors.NewKind("failed to prepare branch for driver %v: %v")
	errFailedPreparePR     = errors.NewKind("failed to prepare pull request for driver %v branch %v: %v")
	errCmdFailed           = errors.NewKind("command failed: %v, output: %v")
)

type pipeLineNode struct {
	logFormat string
	logArgs   []interface{}
	command   string
}

// PrepareBranch does the next steps:
// 1) clones driver's master branch
// 2) creates new branch
// 3) executes custom script if it's not empty
// 4) updates SDK version if it's not empty
// 5) commits and pushes changes to the previously created branch
func PrepareBranch(d discovery.Driver, branch, sdkVersion, script string) error {
	tmpDir, err := ioutil.TempDir("", d.Language)
	if err != nil {
		return err
	}
	log.Debugf("Created temp directory %v", tmpDir)
	defer func() { os.RemoveAll(tmpDir) }()

	url := d.RepositoryURL()
	origin := url
	origin = strings.Replace(origin, "github.com", os.Getenv("APPLICATION")+":"+os.Getenv("TOKEN")+"@github.com", -1) + ".git"

	var pipeLine []pipeLineNode
	pipeLine = append(pipeLine,
		pipeLineNode{
			logFormat: "performing git clone repository %v -> %v",
			logArgs:   []interface{}{url, tmpDir},
			command: fmt.Sprintf("git clone %[1]s %[2]s ; cd %[2]s ; "+
				"git remote rm origin ; git remote add origin %[3]s", shell.Quote(url), shell.Quote(tmpDir), shell.Quote(origin)),
		}, pipeLineNode{
			logFormat: "creating branch %v",
			logArgs:   []interface{}{branch},
			command:   fmt.Sprintf("cd %s ; git checkout -b %s", shell.Quote(tmpDir), shell.Quote(branch)),
		})
	if script != "" {
		pipeLine = append(pipeLine, pipeLineNode{
			logFormat: "executing the script",
			logArgs:   []interface{}{},
			command:   fmt.Sprintf("cd %s ; %v", shell.Quote(tmpDir), script),
		})
	}
	if sdkVersion != "" {
		pipeLine = append(pipeLine, pipeLineNode{
			logFormat: "updating sdk to %v",
			logArgs:   []interface{}{sdkVersion},
			command:   fmt.Sprintf("cd %s ; go mod download ; go mod edit -require github.com/bblfsh/sdk/v3@v%v ; go run ./update.go", shell.Quote(tmpDir), sdkVersion),
		})
	}
	pipeLine = append(pipeLine, pipeLineNode{
		logFormat: "committing the changes",
		logArgs:   []interface{}{},
		command:   fmt.Sprintf("cd %s ; git add -A ; git commit --signoff -m \"%s\"", shell.Quote(tmpDir), commitMsg),
	}, pipeLineNode{
		logFormat: "pushing changes",
		logArgs:   []interface{}{},
		command:   fmt.Sprintf("cd %s ; git push origin %s", shell.Quote(tmpDir), shell.Quote(branch)),
	})

	for _, cmnd := range pipeLine {
		log.Infof(cmnd.logFormat, cmnd.logArgs...)
		if err := ExecCmd(cmnd.command); err != nil {
			return errFailedPrepareBranch.New(d.Language, err)
		}
	}

	log.Infof("driver %v: branch %v has been successfully created", d.Language, branch)
	return nil
}

// PreparePR creates pull request for a given driver's branch
func PreparePR(d discovery.Driver, branch string) error {
	ctx := context.Background()
	client := github.NewClient(oauth2.NewClient(ctx, oauth2.StaticTokenSource(
		&oauth2.Token{AccessToken: os.Getenv("TOKEN")},
	)))

	pr, _, err := client.PullRequests.Create(ctx, org, d.Language+"-driver", &github.NewPullRequest{
		Title:               &branch,
		Head:                &branch,
		Base:                strPtr("master"),
		Body:                strPtr(commitMsg),
		MaintainerCanModify: newTrue(),
	})
	if err != nil {
		return errFailedPreparePR.New(d.Language, branch, err)
	}

	log.Infof("driver %v: pull request %v has been successfully created", d.Language, *pr.ID)
	return nil
}

// ExecCmd executes the specified Bash script. If execution fails, the error contains
// the combined output from stdout and stderr of the script.
// Do not use this for scripts that produce a large volume of output.
func ExecCmd(command string) error {
	cmd := exec.Command("bash", "-c", command)

	data, err := cmd.CombinedOutput()
	log.Debugf("command output: %v", string(data))
	if err != nil {
		return errCmdFailed.New(err, string(data))
	}

	return nil
}

func strPtr(s string) *string {
	return &s
}

func newTrue() *bool {
	b := true
	return &b
}
